- 연산자 : 연산을 수행하는 기호
    +, -, *, /
- 피연산자 : 연산자의 연산 수행 대상
    x(피연산자) +(연산자) 3(피연산자)

    "모든 연산자는 연산결과를 반환한다."
        ex) 4 * x +3
            4 * 5 + 3
        -> 20 + 3
        -> 23

        y = 4 * x + 3;          // x 의 값이 5 라면, y 의 값은 23이 된다.
        System.out.println(y);  // y 의 값인 23이 화면에 출력된다.

- 연산자의 종류

      종류                    연산자                    설명
    산술 연산자          +, -, *, /, %, <<, >>       사칙 연산과 나머지 연산(%)
    비교 연산자          >, <, >=, <=, ==, !=        크고 작음과 같고 다름을 비교
    논리 연산자          &&, ||, !, &, |, ^, ~       '그리고(AND)' 와 '또는(OR)' 으로 조건을 연결
    대입 연산자                   =                  우변의 값을 좌변에 저장
    기타                (type) ? : instanceof       형변환 연산자, 삼함 연산자, instanceof 연산자

- 연산자의 우선순위
    "하나의 식(expression)에 연산자가 둘 이상 있을 때, 어떤 연산을 먼저 수행할지를 자동 결정 하는것"

    1. 산술 > 비교 > 논리 > 대입. 대입은 제일 마지막에 수행된다
    2. 단항(피연산자가 1개) > 이항(피연산자가 2개) > 삼함(피연산자가 3개). 단항 연산자의 우선순위가 이항 연산자보다 높다
    3. 단한 연산자와 대입 연산자를 제외한 모든 연산 의 진행방향은 왼쪽에서 오른쪽이다

- 증감 연산자
    증가 연산자(++) 피연산자의 값을 1 증가시킨다
    감소 연산자(--) 피연산자의 값을 1 감소시킨다

    타입                  설명               사용예
    전위형     값이 참조되기 전에 증가시킨다    j = ++i;
    후위형     값이 참조된 후에 증가시킨다      j = i++;

    "증감 연산자가 독립적으로 사용된 경우, 전위형과 후위형의 차이가 없다."

    증감 연산자가 포함된 식을 이해하기 어려울 때는 다음과 괕이 증감 연산자를 따로 떼어내면 이해하기 쉽다.
    전위형의 경우 증감 연산자를 식의 이전으로

    j = ++i; // 전위형 -> ++i;    // 증가 후에
                         j = i;  // 참조하여 대입

    후위형의 경우 증감 연산자를 식의 이후로 떼어내면 된다.

    j = i++; // 후위형 -> j = i; // 참조하여 대입 후에
                         i++;   // 증가

- 부호 연산자
    '-' 는 피연산자의 부호를 반대로 변경
    '+' 는 아무런 일도 하지 않는다 (실제 사용 X)

- 형변환 연산자
    변수 또는 상수의 타입을 다른 타입으로 변환하는 것

    (타입) 피연산자

    double d = 85.4;
    int score = (int)d;

 -> int score = (int)85.4;
 -> int score = 85;

     변환          수식      결과
 int -> char    (char)65    'A'
 char -> int    (int)'A'    65
 float -> int   (int)1.6f   1
 int -> float   (float)10   10.0f

- 자동 형변환
                생략
    float f = (float) 1234; // int 타입의 값을 float 타입의 변수에 저장

    int i = 3.14f; // 에러
    int i = (int)3.14f;
           수동형변환

    형변환을 하는 이유는 주로 서로 다른 두 타입을 일치시키기 위해서한다.
    형변환을 생략하면 컴파일러가 알아서 자동으로 형변환을 한다.
    "기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환 한다"
    그래서 표현범위가 좁은 타입에서 넓은 타입으로 형변환하는 경우에는 값 손실이 없으므로
    두 타입 중에서 표현범위가 더 넓은 쪽으로 형변환 한다.

- 사칙 연산자 (+, -, *, /)

    int int  int
    10 / 4 -> 2 // 소수점 이하는 버려진다

    int  float   float  float   float
    10 / 4.0f -> 10.0f / 4.0f -> 2.5f

- 산술 변환
    "연산 전에 피연산자의 타입을 일치시키는 것"

    1) 두 피연산자의 타입을 일치시킨다 (큰 타입으로 일치)
        long + int -> long + long -> long
        float + int -> float + float -> float
        double + float -> double + double -> double
    2) 피연산자의 타입이 int 보다 작은 타입은 int 로 변환된다.
        byte + short -> int + int -> int
        char + short -> int + int -> int

- 반올림 (Math.round())
    실수를 소수점 첫번째 자리에서 반올림한 정수를 반환
    long result = Math.round(4.52); // result 에 5 가 저장된다.

    double pi = 3.141592; // 3.141로 바꾸려면?

    System.out.println((int)(pi * 1000)/1000.0); // 3.141 로 봐꾸기

- 나머지 연산자(%)
    오른쪽 피연산자로 나누고 남은 나머지를 반환
    나누는 피연사자는 0 이 아닌 정수만 허용 (부호는 무시)

    int x = 10, y = 8;

    System.out.printf("%d 을 %d 로 나누면, %n", x, y); // 10 을 8 로 나누면,
    System.out.println("몫은 %d 이고, 나머지는 %d 입니다.%n", x /y, x % y); // 몫은 1 이고, 나머지는 2 입니다.

- 비교 연산자 (>, < >=, <= ==, !=)
    두 피연산자를 비교해서 true(참) 또는 false(거짓)을 반환

              대소비교 연산자의 종류와 연산결과
    비교연산자                       연산결과
        >               좌변 값이 크면, true 아니면 false
        <               좌변 값이 작으면, true 아니면 false
        >=              좌변 값이 크거나 같으면, true 아니면 false
        <=              좌변 값이 작거나 같으면, true 아니면 false

              등가비교 연산자의 종류와 연산결과
    비교연산자                       연산결과
       ==                   두 값이 같으면, true 아니면 false
       !=                   두 값이 다르면, true 아니면 false

- 문자열의 비교
    문자열 비교에는 == 대신 equals()를 사용해야 한다.

    String str1 = "abc";
    String str2 = "abc";

    System.out.println(str1 == str2); // true
    System.out.println((str1.equals(str2)); // true

    new 연산자를 이용해서 객체생성시

    String str1 = new String("abc");
    String str2 = new String("abc");

    System.out.println(str1 == str2); // 등가비교시 false 가 반환 될수 있다.
    System.out.println((str1.equals(str2)); // true

- 논리 연산자 (%%, ||)
    조건식을 연결할 때 사용하는 연산자

    || (OR 결합)  피연산자 중 어느 한 쪽이 true 이면 true 를 결과로 얻는다.
    && (AND 결합) 피연산자 양쪽 모두 true 이여야 true 를 결과로 얻는다.

        x     y    x || y  x && y
      true   true   true    ture
      ture   false  true    false
      false  ture   true    false
      false  false  false   false

    1) x는 10보다 크고 20보다 작다
        'x > 10' 와 'x < 20'  가 '그리고(and)'로 연결된 조건이므로 다음과 같이 쓸 수 있다.

                            x > 10 && x < 20

        'x > 10' 는 '10 < x' 와 같으므로 다음과 같이 쓸 수 있다.
        보통은 변수를 왼쪽에 쓰지만 이런 경우 가독성측면에서 보면 아래의 식이 더 나을 수 있다.

                            10 < x && x < 20

    2) i 는 2의배수 또는 3의 배수이다.
        어떤 수가 2의 배수라는 얘기는 2로 나누었을 때 나머지가 0이라는 뜻이다.
        그래서 나머지 연산의 결과가 0인지 확인해야 한다.
        '또는'으로 두 조건이 연결되어있으므로 논리 연산자 ' ||(OR) '를 사용해야 한다.

                            i % 2 == 0 || i % 3 == 0

        i 의 값이 8일 때, 위의 식은 다음과 같은 과정으로 연산된다.

                            i % 2 == 0 || i % 3 == 0
                         -> 8 % 2 == 0 || 8 % 3 == 0
                         ->     0 == 0 || 2 == 0
                         ->       true || false
                         ->           true

    3) i 는 2의 배수 또는 3의 배수지만 6의 배수는 아니다.
        이전 조건에 6의 배수를 제외하는 조건이 더 붙었다.
        6의 배수가 아니여야 한다는 조건은 ' i % 6 != 0'이고, 이 조건을 ' &&(AND) ' 로 연결해야 한다.

                            ( i % 2 == 0 ||  i % 3 == 0 ) && i % 6 != 0

        위의 식에 괄호를 사용한 이유는 ' && '가 ' || '보다 우선순위가 높기 때문이다.
        만일 괄호를 사용하지 않으면 ' && '를 먼저 연산한다. 다음의 두 식은 동일하다.

                            i % 2 == 0 ||   i % 3 == 0 && i % 6 != 0
                            i % 2 == 0 || ( i % 3 == 0 && i % 6 != 0 )

    4) 문자 ch 는 숫자( '0' ~ '9' ) 이다.
        사용자로부터 입력된 문자가 숫자( '0' ~ '9' )인지 확인하는 식은 다음과 같이 쓸 수 있다.

                            '0' <= ch && ch <= '9'

        유니코드에서 문자 '0'부터 '9'까지 연속적으로 배치되어 있기 때문에 가능한 식이다.
        문자 '0'부터 '9'까지 유니코드는 10진수로 다음과 같다.

                      문자    '0' '1' '2' '3' '4' '5' '6' '7' '8' '9'
                    유니코드   48  49  50  51  52  53  54  55  56  57

    5) 문자 ch 는 대문자 또는 소문자이다.
        4)의 경우와 마찬가지로 문자 'a' 부터 'z' 까지, 그리고 'A' 부터 'Z' 까지도 연속적으로
        배치되어 있으므로 문자 ch 가 대문자 또는 소문자인지 확인하는 식은 다음과 같이 쓸 수 있다.

                    ( 'a' <= ch && ch <= 'z' ) || ( 'A' <= ch && ch <= 'Z')

- 논리 부정 연산자 ( ! )
    true 를 false 로, false 를 true 로 바꾼다.

                                x       y
                               ture    false
                               false   ture

                   boolean b = ture;
                   !!b -> ! !ture -> !false -> ture

                   문자 ch 가 소문자가 아니다
                   ch < 'a' || ch > 'z' <-----> !('a' <= ch && ch <= 'z')

- 조건 연산자 ( ?, : )
    조건식의 결과에 따라 연산결과를 달리한다.

                   조건식이 참(ture)이면 식1
                 조건식 ? 식1 : 식2
                       조건식이 거짓(false)이면 식2

         result = (x > y) ? x : y; // 괄호 생략 가능

         result = (5 > 3) ? 5 : 3;
      -> result = (ture) ? 5 : 3;
      -> result = 5;
                                            if( x > y)
         result = (x > y) ? x : y; <----->      result = x; // x > y 가 ture 일때
                                            else
                                                result = y; // x > y 가 false 일때

- 대입 연산자
    오른쪽 피연산자를 왼쪽 피연산자에 저장 후 저장된 값을 반환

       System.out.println(x = 3); // 변수 x 에 3이 저장되고
    -> System.out.println(3);     // 연산결과인 3이 출력된다.

    lvalue - 대입 연산자의 왼쪽 피연산자
    rvalue - 대입 연산자의 오른쪽 피연산자

                x    =   3
              lvalue   rvalue

    int i = 0;
    3 = i + 3; // 에러. lvalue 가 값을 저장할 수 있는 공간이 아니다.
    i + 3 = i; // 에러. lvalue 의 연산결과가 리터럴 (i + 3 -> 0 + 3 -> 3)

    final int MAX = 3; // 변수 앞에 키워드 final 을 붙이면 상수가 된다.
    MAX = 10; // 에러. 상수(MAX)에 새로운 값을 저장할 수 없다.

- 복합 대입 연산자
    대입 연산자와 다른 연산자를 하나로 축약

                      op=             =
                    i += 3;       i = i + 3;
                    i -= 3;       i = i - 3;
                    i *= 3;       i = i * 3;
                    i /= 3;       i = i / 3;
                    i %= 3;       i = i % 3;
                    i <<= 3;      i = i << 3;
                    i >>= 3;      i = i >> 3;
                    i &= 3;       i = i & 3;
                    i ^= 3;       i = i ^ 3;
                    i |= 3;       i = i | 3;
                    i *= 10 + j;  i = i (10 + j);
